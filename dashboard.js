// Generated by CoffeeScript 1.6.3
(function() {
  var AUTOREFRESH_HOURS, Card, CardView, Cards, CompleteCardsView, GCAL_FEED_URL_LS_KEY, List, Lists, NAME_TO_INITIALS_MAPPING, PIPEDRIVE_API_BASE, PIPEDRIVE_API_KEY_LS_KEY, REFRESH_INTERVAL, TRELLO_BOARDS, User, Users, calendarCards, formatCardMetaData, getBoardCards, getCompletedCards, getHash, getMonday, getPipedriveActivities, handleFeed, lists, loadInitialData, refreshPage, setAvatarStyle, updateCalendar, updateGcal, updatePipedrive, users;

  TRELLO_BOARDS = ['UsP5zlas'];

  REFRESH_INTERVAL = 60000;

  AUTOREFRESH_HOURS = 6;

  GCAL_FEED_URL_LS_KEY = 'arachnysDashboardFeedUrl';

  PIPEDRIVE_API_KEY_LS_KEY = 'arachnysPipedriveApiKey';

  PIPEDRIVE_API_BASE = 'https://api.pipedrive.com/v1';

  NAME_TO_INITIALS_MAPPING = {
    "David Buxton": "DB",
    "Mike Cerillo": "MC",
    "Lynn Petesch": "L",
    "Aaron Tanner": "AT",
    "Hollie Tu": "HT",
    "Enric Castane": "EC",
    "Minna Cowper-Coles": "MCC",
    "Board Members": "BM",
    "david": "DB",
    "harry": "HW",
    "matthew": "MB",
    "mateusz": "MK",
    "james": "JP"
  };

  window.calendarEvents = {};

  window.organizationMembers = {};

  window.organizationMembersInitials = {};

  window.boardLists = {};

  List = Backbone.Model.extend({
    defaults: {
      id: null,
      url: null,
      name: "No name"
    }
  });

  User = Backbone.Model.extend({
    defaults: {
      initials: "NI",
      name: "No name",
      avatarHash: null
    }
  });

  Card = Backbone.Model.extend({
    defaults: {
      id: null,
      title: "No title",
      url: "#",
      start: null,
      end: null,
      "class": "card",
      listId: null,
      complete: false,
      userIds: []
    },
    inPast: function() {
      var now, startDate;
      now = new Date();
      startDate = new Date(this.get('start'));
      if (startDate == null) {
        return false;
      }
      return (now.getTime() - startDate.getTime()) > 0;
    },
    viewEvent: function() {
      return window.location.href = url;
    }
  });

  Cards = Backbone.Collection.extend({
    model: Card
  });

  Users = Backbone.Collection.extend({
    model: User
  });

  Lists = Backbone.Collection.extend({
    model: List,
    initialize: function() {
      return this.cards = new Cards;
    }
  });

  users = new Users;

  lists = new Lists;

  calendarCards = new Cards;

  CardView = Backbone.View.extend({
    tagname: "li",
    template: _.template($('#item-template').html()),
    events: {
      click: "viewEvent"
    },
    initialize: function() {
      return this.listenTo(this.model, 'change', this.render);
    },
    render: function() {
      this.$el.html(this.template(this.model.toJSON()));
      return this;
    }
  });

  CompleteCardsView = Backbone.View.extend({
    el: $("#completed-cards"),
    initialize: function() {
      this.listenTo(CalendarCards, 'add', this.addOne);
      return this.listenTo(CalendarCards, 'reset', this.addAll);
    },
    addOne: function(card) {
      var view;
      if (card.complete) {
        view = new CardView({
          model: card
        });
        return this.$("#completed-cards").append(view.render().el);
      }
    },
    addAll: function() {
      var complete;
      complete = new Cards(CalendarCards.where({
        complete: true
      }));
      return complete.each(this.addOne, this);
    }
  });

  window.onAuthorize = function() {
    updateLoggedIn();
    $("#output").empty();
    return loadInitialData(getBoardCards);
  };

  getMonday = function(d) {
    var day, diff, _ref;
    d = new Date(d);
    day = d.getDay();
    diff = d.getDate() - day + ((_ref = day === 0) != null ? _ref : -{
      6: 1
    });
    return new Date(d.setDate(diff));
  };

  getBoardCards = function(callback) {
    var $noDueDate, firstOfWeek, now;
    getCompletedCards();
    $noDueDate = $('#no-due-date').empty();
    $('<h4>No due date/in past</h4>').appendTo($noDueDate);
    $('<div>').text('Loading...').appendTo($noDueDate);
    now = new Date();
    firstOfWeek = getMonday(now);
    return $.each(TRELLO_BOARDS, function(idx, boardId) {
      return Trello.get("boards/" + boardId + "/cards?filter=visible", function(cards) {
        return $.each(cards, function(ix, card) {
          var boardName, cls, dueDate, link, metadata, prevBoardName;
          calendarCards.create({
            id: card.url,
            title: card.name,
            members: card.userIds,
            listId: card.idList,
            url: card.url,
            start: new Date(card.due).getTime(),
            end: new Date(card.due).getTime(),
            complete: false
          });
          metadata = formatCardMetaData(card.idMembers);
          boardName = window.boardLists[card.idList].name;
          if (boardName === "Complete") {
            cls = "event-success event-fade " + metadata.avatarString + " " + (metadata.avatarString !== '' ? 'event-large' : '');
          } else if (boardName === "In progress") {
            cls = "event-progress " + metadata.avatarString + " " + (metadata.avatarString !== '' ? 'event-large' : '') + " " + (inPast(card.due, now) ? 'event-in-past' : '');
          } else {
            cls = "event-not-started " + metadata.avatarString + " " + (metadata.avatarString !== '' ? 'event-large' : '') + " " + (inPast(card.due, now) ? 'event-in-past' : '');
          }
          dueDate = new Date(card.due).getTime();
          if (card.due && dueDate > firstOfWeek.getTime()) {
            return window.calendarEvents.trello.push({
              id: card.url,
              title: "" + card.name + metadata.membersString,
              url: card.url,
              start: dueDate,
              end: dueDate,
              "class": cls
            });
          } else {
            if (prevBoardName !== boardName) {
              $("<h5>").text("" + boardName).appendTo($noDueDate);
            }
            link = $("<a>").attr({
              href: card.url,
              target: "trello"
            }).addClass("card " + cls);
            link.text("" + card.name + metadata.membersString).appendTo($noDueDate);
            return prevBoardName = boardName;
          }
        });
      });
    });
  };

  formatCardMetaData = function(members) {
    var i, m, metadata;
    metadata = {};
    metadata.initials = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = members.length; _i < _len; _i++) {
        m = members[_i];
        _results.push(window.organizationMembers[m].initials);
      }
      return _results;
    })();
    if (metadata.initials.length !== 0) {
      metadata.membersString = " [" + (metadata.initials.join(', ')) + "]";
      metadata.avatarStyles = (function() {
        var _i, _len, _ref, _results;
        _ref = metadata.initials;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _results.push("avatar-" + i);
        }
        return _results;
      })();
      metadata.avatarString = "" + (metadata.avatarStyles.join(' '));
    } else {
      metadata.membersString = "";
      metadata.avatarString = "";
    }
    return metadata;
  };

  getCompletedCards = function() {
    var now;
    now = new Date();
    return $.each(TRELLO_BOARDS, function(idx, boardId) {
      return Trello.get("boards/" + boardId + "/cards?filter=closed&limit=100", function(cards) {
        var card, cardClosedDate, daysAgoClosed, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = cards.length; _i < _len; _i++) {
          card = cards[_i];
          cardClosedDate = new Date(card.dateLastActivity);
          daysAgoClosed = (now - cardClosedDate) / 1000 / 3600 / 24;
          if (daysAgoClosed <= 7.0) {
            _results.push(calendarCards.create({
              id: card.url,
              title: card.name,
              members: card.userIds,
              listId: card.idList,
              url: card.url,
              start: new Date(card.due).getTime(),
              end: new Date(card.due).getTime(),
              complete: true
            }));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    });
  };

  loadInitialData = function(callback) {
    return Trello.members.get("me", function(member) {
      $("#fullName").text(member.fullName);
      return Trello.get("organizations/arachnys1/members?fields=all", function(members) {
        var boardId, _i, _j, _len, _len1;
        for (_i = 0, _len = members.length; _i < _len; _i++) {
          member = members[_i];
          users.create({
            id: member.id,
            initials: member.initials,
            avatarHash: member.avatarHash
          });
        }
        for (_j = 0, _len1 = TRELLO_BOARDS.length; _j < _len1; _j++) {
          boardId = TRELLO_BOARDS[_j];
          Trello.get("boards/" + boardId + "/lists", function(lists) {
            var list, _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = lists.length; _k < _len2; _k++) {
              list = lists[_k];
              _results.push(lists.create({
                id: list.id,
                name: list.name
              }));
            }
            return _results;
          });
        }
        return callback();
      });
    });
  };

  setAvatarStyle = function(initials, avatarHash) {
    var imageUrl;
    imageUrl = "https://trello-avatars.s3.amazonaws.com/" + avatarHash + "/30.png";
    return $("<style type='text/css'>.avatar-" + initials + " { background-image: url('" + imageUrl + "'); background-repeat: no-repeat; background-position-x:right; } </style>").appendTo('head');
  };

  window.updateLoggedIn = function() {
    var isLoggedIn;
    isLoggedIn = Trello.authorized();
    $("#loggedout").toggle(!isLoggedIn);
    return $("#loggedin").toggle(isLoggedIn);
  };

  window.logout = function() {
    Trello.deauthorize();
    return updateLoggedIn();
  };

  window.getFeed = function() {
    var service;
    service = new google.gdata.calendar.CalendarService('arachnys');
    return service.getEventsFeed(FEED_URL, handleFeed, handleError);
  };

  getHash = function(str) {
    var char, code, hash, _i, _len;
    hash = 0;
    if (str.length === 0) {
      return 0;
    }
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      char = str[_i];
      code = char.charCodeAt(0);
      hash = ((hash << 5) - hash) + code;
      hash |= 0;
    }
    return hash;
  };

  handleFeed = function(feed) {
    var entries, entry, initials, member, metadata, _i, _len;
    entries = feed.entry;
    for (_i = 0, _len = entries.length; _i < _len; _i++) {
      entry = entries[_i];
      calendarCards.create({
        id: getHash(entry.id.$t),
        title: "" + entry.title.$t + " on tech duty",
        url: entry.link[0].href,
        start: new Date(entry['gd$when'][0]['startTime']).getTime(),
        end: new Date(entry['gd$when'][0]['endTime']).getTime(),
        "class": "event-warning " + metadata.avatarString + " event-large"
      });
      initials = NAME_TO_INITIALS_MAPPING[entry.title.$t.toLowerCase()];
      if ((!initials) || (organizationMembersInitials[initials] == null)) {
        console.error("No initials for", entry.title.$t);
        return;
      }
      member = organizationMembersInitials[initials];
      metadata = formatCardMetaData([member.id]);
      window.calendarEvents.gcal.push({
        id: getHash(entry.id.$t),
        title: "" + entry.title.$t + " on tech duty",
        url: entry.link[0].href,
        start: new Date(entry['gd$when'][0]['startTime']).getTime(),
        end: new Date(entry['gd$when'][0]['endTime']).getTime(),
        "class": "event-warning " + metadata.avatarString + " event-large"
      });
    }
    return updateCalendar();
  };

  updateCalendar = function(events) {
    var flat, item, source, _i, _len, _ref;
    flat = [];
    _ref = window.calendarEvents;
    for (source in _ref) {
      events = _ref[source];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        item = events[_i];
        flat.push(item);
      }
    }
    window.calendar.setOptions({
      events_source: flat
    });
    window.calendar2.setOptions({
      events_source: flat
    });
    window.calendar.view();
    return window.calendar2.view();
  };

  updateGcal = function() {
    var feedUrl, url;
    feedUrl = JSON.parse(localStorage.getItem(GCAL_FEED_URL_LS_KEY));
    if (!feedUrl) {
      url = window.prompt('Enter Google Calendar feed URL for tech rota (should end with /full)');
      localStorage.setItem(GCAL_FEED_URL_LS_KEY, JSON.stringify(url));
      feedUrl = JSON.parse(localStorage.getItem(GCAL_FEED_URL_LS_KEY));
    }
    if (feedUrl) {
      return $.getJSON("" + feedUrl + "?alt=json-in-script&callback=?", function(data) {
        handleFeed(data.feed);
        return setTimeout(updateGcal, REFRESH_INTERVAL);
      });
    } else {
      return window.alert('Not possible to load Google Calendar data');
    }
  };

  updatePipedrive = function() {
    var apiKey, key;
    apiKey = JSON.parse(localStorage.getItem(PIPEDRIVE_API_KEY_LS_KEY));
    if (!apiKey) {
      key = window.prompt('Enter Pipedrive API key');
      localStorage.setItem(PIPEDRIVE_API_KEY_LS_KEY, JSON.stringify(key));
      apiKey = JSON.parse(localStorage.getItem(PIPEDRIVE_API_KEY_LS_KEY));
    }
    if (apiKey) {
      setTimeout(updatePipedrive, REFRESH_INTERVAL);
      return getPipedriveActivities(apiKey);
    } else {
      return window.alert('Not possible to load Pipedrive data');
    }
  };

  getPipedriveActivities = function(apiKey) {
    window.calendarEvents.pipedrive = [];
    return $.getJSON("" + PIPEDRIVE_API_BASE + "/users?api_token=" + apiKey, function(data) {
      var u, user, userHash, _i, _j, _len, _len1, _results;
      users = data.data;
      userHash = {};
      for (_i = 0, _len = users.length; _i < _len; _i++) {
        u = users[_i];
        userHash[u.id] = u;
      }
      _results = [];
      for (_j = 0, _len1 = users.length; _j < _len1; _j++) {
        user = users[_j];
        _results.push($.getJSON("" + PIPEDRIVE_API_BASE + "/activities/?done=0&api_token=" + apiKey + "&user_id=" + user.id, function(activityData) {
          var activity, date, initials, member, metadata, _k, _len2, _ref;
          if (activityData.data == null) {
            return;
          }
          _ref = activityData.data;
          for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
            activity = _ref[_k];
            date = new Date(activity.due_date).getTime();
            user = userHash[activity.user_id];
            initials = NAME_TO_INITIALS_MAPPING[user.name];
            if ((!initials) || (organizationMembersInitials[initials] == null)) {
              console.error("No initials for", user);
              return;
            }
            member = organizationMembersInitials[initials];
            metadata = formatCardMetaData([member.id]);
            window.calendarEvents.pipedrive.push({
              id: activity.id,
              title: "" + activity.subject + " " + metadata.membersString,
              url: "https://app.pipedrive.com/org/details/" + activity.org_id,
              start: date,
              end: date,
              "class": "event-warning " + metadata.avatarString + " event-large"
            });
          }
          return updateCalendar();
        }));
      }
      return _results;
    });
  };

  window.getEventLine = function(eventHash, idx) {
    var hasItem, k, ret, v;
    ret = {};
    hasItem = false;
    for (k in eventHash) {
      v = eventHash[k];
      if (idx < v.length) {
        hasItem = true;
        ret[k] = v[idx];
      } else {
        ret[k] = null;
      }
    }
    if (hasItem) {
      return ret;
    } else {
      return {};
    }
  };

  refreshPage = function() {
    return window.location.href = window.location.href;
  };

  $(function() {
    window.calendar = $('#calendar').calendar({
      first_day: 1,
      show_weekends: 0,
      events_source: []
    });
    window.calendar2 = $('#calendar2').calendar({
      first_day: 1,
      show_weekends: 0,
      events_source: []
    });
    window.calendar.view('week');
    window.calendar2.view('week');
    window.calendar2.navigate('next');
    setTimeout(updateGcal, 1000);
    return setTimeout(refreshPage, 1000 * 60 * 60 * AUTOREFRESH_HOURS);
  });

}).call(this);
